# vim: set ft=sh syn=bash :
# shellcheck shell=bash

#
# Copyright (C) 2022 Chris 'sh0shin' Frage
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License, version 3,
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#

# duct-git
# Git operations.

# Git working directory.
declare -g DUCT_GIT_WORKDIR="${DUCT_GIT_WORKDIR:-"$PWD"}"

# Default git branch name.
declare -g DUCT_GIT_BRANCH="${DUCT_GIT_BRANCH:-"main"}"

# Default git remote name.
declare -g DUCT_GIT_REMOTE="${DUCT_GIT_REMOTE:-"origin"}"

# git local head

declare -g DUCT_GIT_LOCAL_HEAD_PATH="${DUCT_GIT_LOCAL_HEAD_PATH:-$DUCT_GIT_WORKDIR}"

# deps: duct-msg
# intl: false
# life: core
# desc: Return current local HEAD.
# opts:
__duct_git_local_head() {
  local LOCAL_HEAD

  if [[ -d "${DUCT_GIT_LOCAL_HEAD_PATH}/.git" ]]
  then
    LOCAL_HEAD="$( __duct_run git -C "$DUCT_GIT_LOCAL_HEAD_PATH" describe --all 2>/dev/null )"
    LOCAL_HEAD="${LOCAL_HEAD##*/}"
    __duct_msg d "$LOCAL_HEAD"
    echo "$LOCAL_HEAD"
    return
  else
    __duct_msg e "'$DUCT_GIT_LOCAL_HEAD_PATH' not a git repository!"
    return 1
  fi
}
readonly -f __duct_git_local_head

# git local branch

declare -g -a -x DUCT_GIT_LOCAL_BRANCH_LIST=()

declare -g DUCT_GIT_LOCAL_BRANCH_PATH="${DUCT_GIT_LOCAL_BRANCH_PATH:-$DUCT_GIT_WORKDIR}"

declare -g DUCT_GIT_LOCAL_BRANCH_NAME="${DUCT_GIT_LOCAL_BRANCH_NAME:-}"

__duct_git_local_branch() {
  readarray -t DUCT_GIT_LOCAL_BRANCH_LIST < <( __duct_run git -C "$DUCT_GIT_LOCAL_BRANCH_PATH" branch --no-color --list --format='%(refname:lstrip=2)' )

  __duct_msg d "${DUCT_GIT_LOCAL_BRANCH_LIST[*]}"
}
readonly -f __duct_git_local_branch

# git remote branch

declare -g -a -x DUCT_GIT_REMOTE_BRANCH_LIST=()

declare -g DUCT_GIT_REMOTE_BRANCH_PATH="${DUCT_GIT_REMOTE_BRANCH_PATH:-$DUCT_GIT_WORKDIR}"

declare -g DUCT_GIT_REMOTE_BRANCH_NAME="${DUCT_GIT_REMOTE_BRANCH_NAME:-}"

__duct_git_remote_branch() {
  readarray -t DUCT_GIT_REMOTE_BRANCH_LIST < <( __duct_run git -C "$DUCT_GIT_REMOTE_BRANCH_PATH" branch --remote --no-color --list --format='%(refname:lstrip=3)' )

  __duct_msg d "${DUCT_GIT_REMOTE_BRANCH_LIST[*]}"
}
readonly -f __duct_git_remote_branch

# git remote head

declare -g DUCT_GIT_REMOTE_HEAD_PATH="${DUCT_GIT_REMOTE_HEAD_PATH:-$DUCT_GIT_WORKDIR}"

declare -g DUCT_GIT_REMOTE_HEAD_REMOTE="${DUCT_GIT_REMOTE_HEAD_REMOTE:-$DUCT_GIT_REMOTE}"

# deps: duct-msg
# intl: false
# life: core
# desc: Return current remote HEAD.
# opts:
__duct_git_remote_head() {
  local REMOTE_HEAD

  if [[ -d "${DUCT_GIT_REMOTE_HEAD_PATH}/.git" ]]
  then
    # shellcheck disable=SC2046
    set -- $( __duct_run git -C "$DUCT_GIT_REMOTE_HEAD_PATH" ls-remote --symref "$DUCT_GIT_REMOTE_HEAD_REMOTE" HEAD )

    if [[ "${1:-}" == "ref:" ]]
    then
      REMOTE_HEAD="${2##*/}"
    else
      __duct_msg w "no remote head!"
      return
    fi

    __duct_msg d "$REMOTE_HEAD"
    echo "$REMOTE_HEAD"
    return
  else
    __duct_msg d "'$DUCT_GIT_REMOTE_HEAD_PATH' not a git repository!"
    return 1
  fi
}
readonly -f __duct_git_remote_head

# git config

# Git configuration file (inherit GIT_CONFIG).
declare -g DUCT_GIT_CONFIG_FILE="${DUCT_GIT_CONFIG_FILE:-"${GIT_CONFIG:-"${HOME}/.gitconfig"}"}"

# Git user.name configuration (inherit GIT_USER_NAME).
declare -g DUCT_GIT_CONFIG_USER_NAME="${DUCT_GIT_CONFIG_USER_NAME:-"${GIT_USER_NAME:-}"}"

# Git user.email configuration (inherit GIT_USER_EMAIL).
declare -g DUCT_GIT_CONFIG_USER_EMAIL="${DUCT_GIT_CONFIG_USER_EMAIL:-"${GIT_USER_EMAIL:-}"}"

# Git init.defaultBranch configuration (inherit DUCT_GIT_BRANCH).
declare -g DUCT_GIT_CONFIG_INIT_DEFAULT_BRANCH="${DUCT_GIT_CONFIG_INIT_DEFAULT_BRANCH:-$DUCT_GIT_BRANCH}"

# Git advice.detachedHead configuration.
declare -g DUCT_GIT_CONFIG_ADVICE_DETACHED_HEAD="${DUCT_GIT_CONFIG_ADVICE_DETACHED_HEAD:-false}"

# Array of Git custom configurations (TODO).
#declare -g -a DUCT_GIT_CONFIG_CUSTOM=( "${DUCT_GIT_CONFIG_CUSTOM[@]}" )

# deps: duct-msg duct-run
# intl: false
# life: core
# desc: Create a minimal git configuration.
# opts:
__duct_git_config() {
  local GIT_ERROR=0

  if [[ -z "$DUCT_GIT_CONFIG_USER_NAME" ]]
  then
    __duct_msg e "DUCT_GIT_CONFIG_USER_NAME is unset!"
    (( GIT_ERROR+=1 ))
  fi

  if [[ -z "$DUCT_GIT_CONFIG_USER_EMAIL" ]]
  then
    __duct_msg e "DUCT_GIT_CONFIG_USER_EMAIL is unset!"
    (( GIT_ERROR+=1 ))
  fi

  if [[ "$GIT_ERROR" -gt 0 ]]
  then
    return 1
  fi

  local _DEFAULT_BRANCH
  local _USER_NAME
  local _USER_EMAIL

  _DEFAULT_BRANCH="$(git config --get init.defaultBranch || :)"
  if [[ -z "$_DEFAULT_BRANCH" ]]
  then
    __duct_msg d "no default branch!"
  else
    __duct_msg d "current default branch: '$_DEFAULT_BRANCH'"
  fi

  _USER_NAME="$(git config --get user.name || :)"
  if [[ -z "$_USER_NAME" ]]
  then
    __duct_msg d "no user name!"
  else
    __duct_msg d "current user name: '$_USER_NAME'"
  fi

  _USER_EMAIL="$(git config --get user.email || :)"
  if [[ -z "$_USER_EMAIL" ]]
  then
    __duct_msg d "no user email!"
  else
    __duct_msg d "user email: '$_USER_EMAIL'"
  fi

  _ADVICE_DETACHED_HEAD="$( git config --get advice.detachedHead || : )"
  if [[ -z "$_ADVICE_DETACHED_HEAD" ]]
  then
    __duct_msg d "no advice detachedHead!"
  else
    __duct_msg d "advice detachedHead: '$_ADVICE_DETACHED_HEAD'"
  fi

  if [[ "$DUCT_GIT_CONFIG_INIT_DEFAULT_BRANCH" != "$_DEFAULT_BRANCH" ]]
  then
    __duct_msg n "setting default branch: '$_DEFAULT_BRANCH' to '$DUCT_GIT_CONFIG_INIT_DEFAULT_BRANCH'"
    GIT_CONFIG="$DUCT_GIT_CONFIG_FILE" \
    __duct_run git config init.defaultBranch "$DUCT_GIT_CONFIG_INIT_DEFAULT_BRANCH"
  fi

  if [[ "$DUCT_GIT_CONFIG_USER_NAME" != "$_USER_NAME" ]]
  then
    __duct_msg n "setting user name: '$_USER_NAME' to '$DUCT_GIT_CONFIG_USER_NAME'"
    GIT_CONFIG="$DUCT_GIT_CONFIG_FILE" \
    __duct_run git config user.name "$DUCT_GIT_CONFIG_USER_NAME"
  fi

  if [[ "$DUCT_GIT_CONFIG_USER_EMAIL" != "$_USER_EMAIL" ]]
  then
    __duct_msg n "setting user email: '$_USER_EMAIL' to '$DUCT_GIT_CONFIG_USER_EMAIL'"
    GIT_CONFIG="$DUCT_GIT_CONFIG_FILE" \
    __duct_run git config user.email "$DUCT_GIT_CONFIG_USER_EMAIL"
  fi

  if [[ "$DUCT_GIT_CONFIG_ADVICE_DETACHED_HEAD" != "$_ADVICE_DETACHED_HEAD" ]]
  then
    __duct_msg n "setting advice detachedHead: '$_ADVICE_DETACHED_HEAD' to '$DUCT_GIT_CONFIG_ADVICE_DETACHED_HEAD'"
    GIT_CONFIG="$DUCT_GIT_CONFIG_FILE" \
    __duct_run git config advice.detachedHead "$DUCT_GIT_CONFIG_ADVICE_DETACHED_HEAD"
  fi

  # TODO: DUCT_GIT_CONFIG_CUSTOM
}
readonly -f __duct_git_config

# git credential

# Git URL to set credential for (inherit `GIT_USER_SERVER`).
declare -g DUCT_GIT_CREDENTIAL_SERVER="${DUCT_GIT_CREDENTIAL_SERVER:-"${GIT_USER_SERVER:-}"}"

# Token, base64 is supported (inherit `GIT_USER_TOKEN`).
declare -g DUCT_GIT_CREDENTIAL_TOKEN="${DUCT_GIT_CREDENTIAL_TOKEN:-"${GIT_USER_TOKEN:-}"}"

# Username (commonly unused with token).
declare -g DUCT_GIT_CREDENTIAL_USER="${DUCT_GIT_CREDENTIAL_USER:-"git"}"

# deps: duct-msg duct-run duct-util
# intl: false
# life: core
# desc: Configure git credential helper and create a credentials file.
# opts:
__duct_git_credential() {
  local GIT_ERROR=0
  local GIT_CREDENTIAL_FILE="${HOME}/.git-credentials"

  if [[ -z "$DUCT_GIT_CREDENTIAL_TOKEN" ]]
  then
    __duct_msg e "DUCT_GIT_CREDENTIAL_TOKEN is unset!"
    (( GIT_ERROR+=1 ))
  fi

  if [[ -z "$DUCT_GIT_CREDENTIAL_SERVER" ]]
  then
    __duct_msg e "DUCT_GIT_CREDENTIAL_SERVER is unset!"
    (( GIT_ERROR+=1 ))
  else
    __duct_urlinfo "$DUCT_GIT_CREDENTIAL_SERVER"

    if [[ "${DUCT_URLINFO["scheme"]}" != "https" ]]
    then
      __duct_msg e "only a https server is supported: $DUCT_GIT_CREDENTIAL_SERVER"
      (( GIT_ERROR+=1 ))
    fi
  fi

  if [[ $GIT_ERROR -gt 0 ]]
  then
    return 1
  fi

  local _CREDENTIAL_HELPER
  _CREDENTIAL_HELPER="$( git config --get credential.helper || : )"

  if [[ -z "$_CREDENTIAL_HELPER" ]]
  then
    __duct_msg d "no current credential helper"
  else
    __duct_msg d "current credential helper: $_CREDENTIAL_HELPER"
  fi

  if [[ "$_CREDENTIAL_HELPER" != "store" ]]
  then
    __duct_msg n "setting credential helper: '$_CREDENTIAL_HELPER' to 'store'"
    GIT_CONFIG="$DUCT_GIT_CONFIG_FILE" \
    __duct_run git config credential.helper "store"
  fi

  local _GIT_TOKEN
  _GIT_TOKEN="$( __duct_debase64 "$DUCT_GIT_CREDENTIAL_TOKEN" )"

  local _GIT_AUTH="${DUCT_URLINFO["scheme"]}://${DUCT_GIT_CREDENTIAL_USER}:${_GIT_TOKEN}@${DUCT_URLINFO["host"]}"

  DUCT_SFILE_OVERWRITE=true \
  DUCT_SFILE_FILEMODE=0600 \
  __duct_sfile "$GIT_CREDENTIAL_FILE" "$_GIT_AUTH"
}
readonly -f __duct_git_credential

# git fetch

# Options for git fetch command (defaults).
declare -a -r _DUCT_GIT_FETCH_OPTIONS=(
  --all
  --prune
  --quiet
)

# Path to fetch in (inherit `DUCT_GIT_WORKDIR`).
declare -g DUCT_GIT_FETCH_PATH="${DUCT_GIT_FETCH_PATH:-$DUCT_GIT_WORKDIR}"

# Options for git fetch command.
declare -g -a DUCT_GIT_FETCH_OPTIONS=( "${DUCT_GIT_FETCH_OPTIONS[@]:-${_DUCT_GIT_FETCH_OPTIONS[@]}}" )

# deps: duct-msg duct-run
# intl: false
# life: core
# desc: Run git fetch on a repository.
# opts:
__duct_git_fetch() {

  if [[ -d "${DUCT_GIT_FETCH_PATH}/.git" ]]
  then
    __duct_msg n "$DUCT_GIT_FETCH_PATH"
    __duct_run git -C "$DUCT_GIT_FETCH_PATH" fetch "${DUCT_GIT_FETCH_OPTIONS[@]}"
  else
    __duct_msg e "'$DUCT_GIT_FETCH_PATH' not a git repository!"
    return 1
  fi
}
readonly -f __duct_git_fetch

# git checkout

# Options for git checkout command (defaults).
declare -a -r _DUCT_GIT_CHECKOUT_OPTIONS=(
  --quiet
)

# Options for git checkout command.
declare -g -a DUCT_GIT_CHECKOUT_OPTIONS=( "${DUCT_GIT_CHECKOUT_OPTIONS[@]:-${_DUCT_GIT_CHECKOUT_OPTIONS[@]}}" )

# Path to checkout in (inherit `DUCT_GIT_WORKDIR`).
declare -g DUCT_GIT_CHECKOUT_PATH="${DUCT_GIT_CHECKOUT_PATH:-$DUCT_GIT_WORKDIR}"

# Run git fetch before checkout.
declare -g DUCT_GIT_CHECKOUT_FETCH="${DUCT_GIT_CHECKOUT_FETCH:-true}"

# Git branch, commit or tag to checkout.
declare -g DUCT_GIT_CHECKOUT_BRANCH="${DUCT_GIT_CHECKOUT_BRANCH:-$DUCT_GIT_BRANCH}"

# deps: duct-msg duct-run
# intl: false
# life: core
# desc: Run git checkout on a specified branch or tag.
# opts:
__duct_git_checkout() {
  local -a GIT_OPTS=()
  local GIT_LOCAL_HEAD

  if [[ -d "${DUCT_GIT_CHECKOUT_PATH}/.git" ]]
  then

    if [[ "$DUCT_GIT_CHECKOUT_FETCH" == true ]]
    then
      DUCT_GIT_FETCH_PATH="$DUCT_GIT_CHECKOUT_PATH" \
      __duct_git_fetch
    fi

    GIT_LOCAL_HEAD="$( DUCT_GIT_LOCAL_HEAD_PATH="$DUCT_GIT_CHECKOUT_PATH" __duct_git_local_head )"

    if [[ "$DUCT_GIT_CHECKOUT_BRANCH" == "$GIT_LOCAL_HEAD" ]]
    then
      __duct_msg n "$DUCT_GIT_CHECKOUT_PATH at $DUCT_GIT_CHECKOUT_BRANCH"
      return 0
    fi

    DUCT_GIT_REMOTE_BRANCH_PATH="$DUCT_GIT_CHECKOUT_PATH"\
    __duct_git_remote_branch

    DUCT_GIT_LOCAL_BRANCH_PATH="$DUCT_GIT_CHECKOUT_PATH" \
    __duct_git_local_branch

    if [[ ! "${DUCT_GIT_REMOTE_BRANCH_LIST[*]}" =~ $DUCT_GIT_CHECKOUT_BRANCH ]] #&& [[ ! "${DUCT_GIT_LOCAL_BRANCH_LIST[*]}" =~ $DUCT_GIT_CHECKOUT_BRANCH ]]
    then
      GIT_OPTS+=( -B )
    fi

    __duct_msg n "$DUCT_GIT_CHECKOUT_BRANCH"
    __duct_run git -C "$DUCT_GIT_CHECKOUT_PATH" checkout "${DUCT_GIT_CHECKOUT_OPTIONS[@]}" "${GIT_OPTS[@]}" "$DUCT_GIT_CHECKOUT_BRANCH"

  else
    __duct_msg e "'$DUCT_GIT_CHECKOUT_PATH' not a git repository!"
    return 1
  fi
}
readonly -f __duct_git_checkout

# git clone

# Options for `git clone` (defaults).
declare -a -r _DUCT_GIT_CLONE_OPTIONS=(
  --progress
)

# Options for `git clone`.
declare -g -a DUCT_GIT_CLONE_OPTIONS=( "${DUCT_GIT_CLONE_OPTIONS[@]:-${_DUCT_GIT_CLONE_OPTIONS[@]}}" )

# Path to clone in (inherit `DUCT_GIT_WORKDIR`).
declare -g DUCT_GIT_CLONE_PATH="${DUCT_GIT_CLONE_PATH:-$DUCT_GIT_WORKDIR}"

# Branch name to clone.
declare -g DUCT_GIT_CLONE_BRANCH="${DUCT_GIT_CLONE_BRANCH:-}"

# Remote name to clone (inherit DUCT_GIT_REMOTE).
declare -g DUCT_GIT_CLONE_REMOTE="${DUCT_GIT_CLONE_REMOTE:-$DUCT_GIT_REMOTE}"

# Enable/disable git pull if repository exists.
declare -g DUCT_GIT_CLONE_PULL="${DUCT_GIT_CLONE_PULL:-true}"

# URL to clone from.
declare -g DUCT_GIT_CLONE_URL="${DUCT_GIT_CLONE_URL:-}"

# Path to clone, or pull from (with optional prefix).
declare -g DUCT_GIT_CLONE_PATH="${DUCT_GIT_CLONE_PATH:-}"

# Name of tag, commit or branch to checkout after clone.
declare -g DUCT_GIT_CLONE_CHECKOUT="${DUCT_GIT_CLONE_CHECKOUT:-}"

# deps: duct-msg duct-run
# intl: false
# life: core
# desc: Clone a git repository with optional pull.
# opts:
__duct_git_clone() {
  local -a GIT_OPTS=()
  local GIT_RC=0

  if [[ -z "$DUCT_GIT_CLONE_URL" ]]
  then
    __duct_msg e "no git url!"
    return 1
  fi

  # remote
  if [[ -n "$DUCT_GIT_CLONE_REMOTE" ]]
  then
    GIT_OPTS+=(
      --origin "$DUCT_GIT_CLONE_REMOTE"
    )
  fi

  # branch
  if [[ -n "$DUCT_GIT_CLONE_BRANCH" ]]
  then
    GIT_OPTS+=(
      --branch "$DUCT_GIT_CLONE_BRANCH"
    )
  fi

  if [[ ! -d "${DUCT_GIT_CLONE_PATH}/.git" ]]
  then
    __duct_msg n "'$DUCT_GIT_CLONE_URL' to '$DUCT_GIT_CLONE_PATH'"
    __duct_run git clone "${DUCT_GIT_CLONE_OPTIONS[@]}" "${GIT_OPTS[@]}" "$DUCT_GIT_CLONE_URL" "$DUCT_GIT_CLONE_PATH" || GIT_RC=$?

    if [[ "$GIT_RC" -gt 0 ]]
    then
      return $GIT_RC
    fi

    if [[ -n "$DUCT_GIT_CLONE_CHECKOUT" ]]
    then
      DUCT_GIT_CHECKOUT_BRANCH="$DUCT_GIT_CLONE_CHECKOUT" \
      DUCT_GIT_CHECKOUT_FETCH=false \
      DUCT_GIT_CHECKOUT_PATH="$DUCT_GIT_CLONE_PATH" \
      __duct_git_checkout
      return
    fi
  else
    if [[ "$DUCT_GIT_CLONE_PULL" == true ]]
    then
      DUCT_GIT_PULL_BRANCH="$DUCT_GIT_CLONE_BRANCH" \
      DUCT_GIT_PULL_CHECKOUT="$DUCT_GIT_CLONE_CHECKOUT" \
      DUCT_GIT_PULL_PATH="$DUCT_GIT_CLONE_PATH" \
      DUCT_GIT_PULL_REMOTE="$DUCT_GIT_CLONE_REMOTE" \
      __duct_git_pull
      return
    fi
  fi
}
readonly -f __duct_git_clone

# git pull

# Options for `git pull` (defaults).
declare -g -a -r _DUCT_GIT_PULL_OPTIONS=(
  --progress
  --prune
  --tags
)

# Options for `git pull`.
declare -g -a DUCT_GIT_PULL_OPTIONS=( "${DUCT_GIT_PULL_OPTIONS[@]:-${_DUCT_GIT_PULL_OPTIONS[@]}}" )

# Path to pull in (inherit `DUCT_GIT_WORKDIR`)
declare -g DUCT_GIT_PULL_PATH="${DUCT_GIT_PULL_PATH:-$DUCT_GIT_WORKDIR}"

# Remote name to pull (inherit DUCT_GIT_REMOTE).
declare -g DUCT_GIT_PULL_REMOTE="${DUCT_GIT_PULL_REMOTE:-$DUCT_GIT_REMOTE}"

# Branch name to pull.
declare -g DUCT_GIT_PULL_BRANCH="${DUCT_GIT_PULL_BRANCH:-}"

# Name of tag, commit or branch to checkout after clone.
declare -g DUCT_GIT_PULL_CHECKOUT="${DUCT_GIT_PULL_CHECKOUT:-}"

# deps: duct-msg duct-run
# intl: false
# life: core
# desc: Pull a git repository.
# opts:
__duct_git_pull() {
  local GIT_BRANCH="$DUCT_GIT_PULL_BRANCH"
  local GIT_CHECKOUT="$DUCT_GIT_PULL_CHECKOUT"

  if [[ -d "${DUCT_GIT_PULL_PATH}/.git" ]]
  then

    if [[ -z "$GIT_BRANCH" ]]
    then
      GIT_BRANCH="$(
        DUCT_GIT_REMOTE_HEAD_PATH="$DUCT_GIT_PULL_PATH" \
        DUCT_GIT_REMOTE_HEAD_REMOTE="$DUCT_GIT_PULL_REMOTE" \
        __duct_git_remote_head
      )"

      if [[ -z "$GIT_BRANCH" ]]
      then
        __duct_msg w "'$DUCT_GIT_PULL_PATH' nothing to pull!"
        return
      fi
    fi

    if [[ -z "$GIT_CHECKOUT" ]]
    then
      GIT_CHECKOUT="$GIT_BRANCH"
    fi

    if [[ -n "$GIT_CHECKOUT" ]]
    then
      DUCT_GIT_CHECKOUT_BRANCH="$GIT_CHECKOUT" \
      DUCT_GIT_CHECKOUT_FETCH=false \
      DUCT_GIT_CHECKOUT_PATH="$DUCT_GIT_PULL_PATH" \
      __duct_git_checkout
    fi

    __duct_msg n "$DUCT_GIT_PULL_PATH"
    __duct_run git -C "$DUCT_GIT_PULL_PATH" pull "${DUCT_GIT_PULL_OPTIONS[@]}" "$DUCT_GIT_PULL_REMOTE" "$GIT_BRANCH"
  else
    __duct_msg e "'$DUCT_GIT_PULL_PATH' not a git repository!"
  fi
}
readonly -f __duct_git_pull

# git commit

# Options for `git commit` (defaults).
declare -a -r _DUCT_GIT_COMMIT_OPTIONS=(
  --verbose
)

# File(s) to add and commit.
declare -a -r _DUCT_GIT_COMMIT_LIST=()

# Path to commit in (inherit `DUCT_GIT_WORKDIR`).
declare -g DUCT_GIT_COMMIT_PATH="${DUCT_GIT_COMMIT_PATH:-$DUCT_GIT_WORKDIR}"

# Options for `git commit`.
declare -g -a DUCT_GIT_COMMIT_OPTIONS=( "${DUCT_GIT_COMMIT_OPTIONS[@]:-${_DUCT_GIT_COMMIT_OPTIONS[@]}}" )

# Enable/disable Signed-off-by
declare -g DUCT_GIT_COMMIT_SIGNOFF="${DUCT_GIT_COMMIT_SIGNOFF:-false}"

# Enable/disable GPG signing of commit.
declare -g DUCT_GIT_COMMIT_GPG_SIGN="${DUCT_GIT_COMMIT_GPG_SIGN:-false}"

# Branch name to commit to, will be created if not exists (inherit `DUCT_GIT_BRANCH`).
declare -g DUCT_GIT_COMMIT_BRANCH="${DUCT_GIT_COMMIT_BRANCH:-$DUCT_GIT_BRANCH}"

# Reuse branch if it exists.
declare -g DUCT_GIT_COMMIT_BRANCH_REUSE="${DUCT_GIT_COMMIT_BRANCH_REUSE:-true}"

# Remote name to push (inherit `DUCT_GIT_REMOTE`).
declare -g DUCT_GIT_COMMIT_REMOTE="${DUCT_GIT_COMMIT_REMOTE:-$DUCT_GIT_REMOTE}"

# Enable/disable `git push`.
declare -g DUCT_GIT_COMMIT_PUSH="${DUCT_GIT_COMMIT_PUSH:-false}"

# Message to commit with.
declare -g DUCT_GIT_COMMIT_MESSAGE="${DUCT_GIT_COMMIT_MESSAGE:-}"

# Allow empty commits.
declare -g DUCT_GIT_COMMIT_EMPTY="${DUCT_GIT_COMMIT_EMPTY:-false}"

# shellcheck disable=SC2206
# File(s) to add and commit.
declare -g -a DUCT_GIT_COMMIT_LIST=( ${DUCT_GIT_COMMIT_LIST[@]:-${_DUCT_GIT_COMMIT_LIST[@]}} )

# Set to true if commit has changes.
declare -g -x DUCT_GIT_COMMIT_CHANGE=false

# deps: duct-msg duct-run
# intl: false
# life: core
# desc: Commit to a git repository with optional push.
# opts:
__duct_git_commit() {
  local -a GIT_OPTS=()
  local -a GIT_STATUS=()
  local GIT_COMMIT=0
  local GIT_ERROR=0

  if [[ -z "$DUCT_GIT_COMMIT_MESSAGE" ]]
  then
    __duct_msg e "no commit message!"
    (( GIT_ERROR+=1 ))
  fi

  if [[ "${#DUCT_GIT_COMMIT_LIST[@]}" -lt 1 ]]
  then
    __duct_msg e "nothing to commit!"
    (( GIT_ERROR+=1 ))
  fi

  if [[ "$GIT_ERROR" -gt 0 ]]
  then
    return 1
  fi

  if [[ "$DUCT_GIT_COMMIT_SIGNOFF" == true ]]
  then
    GIT_OPTS+=( --signoff )
  fi

  if [[ "$DUCT_GIT_COMMIT_GPG_SIGN" == true ]]
  then
    GIT_OPTS+=( --gpg-sign )
  fi

  DUCT_GIT_CHECKOUT_PATH=$DUCT_GIT_COMMIT_PATH \
  DUCT_GIT_CHECKOUT_BRANCH=$DUCT_GIT_COMMIT_BRANCH \
  __duct_git_checkout

  __duct_msg n "add '${DUCT_GIT_COMMIT_LIST[*]}'"
  __duct_run git -C "$DUCT_GIT_COMMIT_PATH" add "${DUCT_GIT_COMMIT_LIST[@]}"

  # check changes
  readarray -t GIT_STATUS < <( __duct_run git -C "$DUCT_GIT_COMMIT_PATH" status --porcelain=v1 )

  for _STATUS in "${GIT_STATUS[@]}"
  do
    for _FILE in "${DUCT_GIT_COMMIT_LIST[@]}"
    do
      if [[ "$_FILE" == "${_STATUS##* }" ]]
      then
        __duct_msg d "change: $_STATUS"
        (( GIT_COMMIT+=1 ))
      fi
    done
  done

  # allow empty
  if [[ "$DUCT_GIT_COMMIT_EMPTY" == true ]] && [[ "$GIT_COMMIT" -eq 0 ]]
  then
    GIT_OPTS+=( --allow-empty )
    (( GIT_COMMIT+=1 ))
  fi

  if [[ "$GIT_COMMIT" -ge 1 ]]
  then
    __duct_msg n "'$DUCT_GIT_COMMIT_MESSAGE' '${DUCT_GIT_COMMIT_LIST[*]}'"
    __duct_run git -C "$DUCT_GIT_COMMIT_PATH" commit "${DUCT_GIT_COMMIT_OPTIONS[@]}" "${GIT_OPTS[@]}" --message="$DUCT_GIT_COMMIT_MESSAGE" "${DUCT_GIT_COMMIT_LIST[@]}"

    if [[ "$DUCT_GIT_COMMIT_PUSH" == true ]]
    then
      __duct_msg n "push $DUCT_GIT_COMMIT_REMOTE $DUCT_GIT_COMMIT_BRANCH"
      __duct_run git -C "$DUCT_GIT_COMMIT_PATH" push --set-upstream "$DUCT_GIT_COMMIT_REMOTE" "$DUCT_GIT_COMMIT_BRANCH"
    fi

    DUCT_GIT_COMMIT_CHANGE=true
  else
    __duct_msg n "nothing to commit"
  fi
}
readonly -f __duct_git_commit

# git strip remote

# deps: duct-msg duct-run
# intl: false
# life: core
# desc: Strip username and token from a git HTTPS remote URL (uses `DUCT_GIT_REMOTE`).
# opts:
__duct_git_strip_remote() {
  local GIT_REMOTE

  if [[ ! -d .git ]]
  then
    __duct_msg e "not a git repository!"
    exit 1
  fi

  GIT_REMOTE=$( git remote get-url --push "$DUCT_GIT_REMOTE" )

  if [[ ! "$GIT_REMOTE" =~ https:// ]]
  then
    __duct_msg w "not a https remote url, skipping!"
    return 0
  fi

  GIT_REMOTE="$( __duct_gnu_sed -e "s?\(https://\)\(.*\)@\(.*\)?\1\3?g" <<< "$GIT_REMOTE" )"

  __duct_msg n "setting remote $DUCT_GIT_REMOTE to $GIT_REMOTE"
  __duct_run git remote set-url "$DUCT_GIT_REMOTE" "$GIT_REMOTE"
}
readonly -f __duct_git_strip_remote

# git cvc check

# Allowed conventional commits types (defaults).
declare -r -a _DUCT_GIT_CVC_CHECK_TYPES=(
  "build"
  "chore"
  "ci"
  "docs"
  "feat"
  "fix"
  "import"
  "merge"
  "perf"
  "refactor"
  "revert"
  "style"
  "test"
  "todo"
)

# Allowed conventional commits scope (defaults).
declare -r -a _DUCT_GIT_CVC_CHECK_SCOPE=(
  ".*"
)

# Allowed conventional commits description (defaults).
declare -r -a _DUCT_GIT_CVC_CHECK_DESC=(
  "[:space:]"
  "[:digit:]"
  "[:lower:]"
  "[:punct:]"
)

# Path to check conventional commits.
declare -g DUCT_GIT_CVC_CHECK_PATH="${DUCT_GIT_CVC_CHECK_PATH:-$PWD}"

# Allowed conventional commits types.
declare -g -a DUCT_GIT_CVC_CHECK_TYPES=( "${DUCT_GIT_CVC_CHECK_TYPES[@]:-${_DUCT_GIT_CVC_CHECK_TYPES[@]}}" )

# Allowed conventional commits scope.
declare -g -a DUCT_GIT_CVC_CHECK_SCOPE=( "${DUCT_GIT_CVC_CHECK_SCOPE[@]:-${_DUCT_GIT_CVC_CHECK_SCOPE[@]}}" )

# Allowed conventional commits description.
declare -g -a DUCT_GIT_CVC_CHECK_DESC=( "${DUCT_GIT_CVC_CHECK_DESC[@]:-${_DUCT_GIT_CVC_CHECK_DESC[@]}}" )

# Minimal length of conventional commits description.
declare -g -i DUCT_GIT_CVC_CHECK_MIN="${DUCT_GIT_CVC_CHECK_MIN:-5}"

# Maximal length of conventional commits description.
declare -g -i DUCT_GIT_CVC_CHECK_MAX="${DUCT_GIT_CVC_CHECK_MAX:-75}"

# Show passed conventional commits.
declare -g DUCT_GIT_CVC_CHECK_PASS="${DUCT_GIT_CVC_CHECK_PASS:-false}"

# Show failed conventional commits.
declare -g DUCT_GIT_CVC_CHECK_FAIL="${DUCT_GIT_CVC_CHECK_FAIL:-true}"

# Commit(s) to check (default all).
declare -g DUCT_GIT_CVC_CHECK_COMMIT="${DUCT_GIT_CVC_CHECK_COMMIT:-}"

# deps: duct-msg duct-run
# intl: false
# life: test
# desc: Check git conventional commits (<https://www.conventionalcommits.org/>).
# opts:
__duct_git_cvc_check() {
  local -a GIT_DESC
  local -a GIT_FAIL=()
  local -a GIT_LOG
  local -a GIT_PASS=()
  local -a GIT_SCOPE
  local -a GIT_TYPES
  local GIT_COMMIT
  local GIT_MATCH

  local _GIT_AUTHOR
  local _GIT_BREAK
  local _GIT_DESC
  local _GIT_FAIL
  local _GIT_HASH
  local _GIT_PASS
  local _GIT_SCOPE
  local _GIT_TYPE

  if [[ ! -d "${DUCT_GIT_CVC_CHECK_PATH}/.git" ]]
  then
    __duct_msg e "not a git repository!"
    return 1
  fi

  # join matches
  local IFS
  IFS="|" GIT_TYPES=( "${DUCT_GIT_CVC_CHECK_TYPES[*]}" )
  IFS="" GIT_SCOPE=( "${DUCT_GIT_CVC_CHECK_SCOPE[*]}" )
  IFS="" GIT_DESC=( "${DUCT_GIT_CVC_CHECK_DESC[*]}" )
  GIT_MATCH="^(([0-9a-f]+) (${GIT_TYPES[*]})(\(${GIT_SCOPE[*]}\))?(!)?: ([${GIT_DESC[*]}]{${DUCT_GIT_CVC_CHECK_MIN},${DUCT_GIT_CVC_CHECK_MAX}})$)"
  unset IFS

  if [[ -n "$DUCT_GIT_CVC_CHECK_COMMIT" ]]
  then
    readarray -t -n 0 GIT_LOG < <( __duct_run git -C "$DUCT_GIT_CVC_CHECK_PATH" log --pretty='format:%H %s' "$DUCT_GIT_CVC_CHECK_COMMIT" )
  else
    readarray -t -n 0 GIT_LOG < <( __duct_run git -C "$DUCT_GIT_CVC_CHECK_PATH" log --pretty='format:%H %s' )
  fi

  for GIT_COMMIT in "${GIT_LOG[@]}"
  do
    if [[ "$GIT_COMMIT" =~ $GIT_MATCH ]]
    then
      if [[ "$DUCT_GIT_CVC_CHECK_PASS" == true ]]
      then
        _GIT_HASH="${BASH_REMATCH[2]}"
        _GIT_TYPE="${BASH_REMATCH[3]}"
        _GIT_SCOPE="${BASH_REMATCH[4]}"
        _GIT_BREAK="${BASH_REMATCH[5]}"
        _GIT_DESC="${BASH_REMATCH[6]}"
        _GIT_AUTHOR=$( __duct_run git -C "$DUCT_GIT_CVC_CHECK_PATH" log --pretty='format:%aN <%aE>' "${_GIT_HASH}^!" )

        # TODO: check file
        #readarray -t -n 0 _GIT_FILES < <( __duct_run git -C "$DUCT_GIT_CVC_CHECK_PATH" log --name-only --pretty='format:' "${_GIT_HASH}^!" )
        #__duct_msg d "PASS: ${_GIT_FILES[*]}"
        # TODO: check desc

        GIT_PASS+=( "${GIT_COMMIT//${_GIT_HASH} } ($_GIT_AUTHOR) [$_GIT_HASH]" )
      fi
    elif [[ "$GIT_COMMIT" =~ ^(([0-9a-f]+) (.*)$) ]]
    then
      if [[ "$DUCT_GIT_CVC_CHECK_FAIL" == true ]]
      then
        _GIT_HASH="${BASH_REMATCH[2]}"
        _GIT_AUTHOR=$( __duct_run git -C "$DUCT_GIT_CVC_CHECK_PATH" log --pretty='format:%aN <%aE>' "${_GIT_HASH}^!" )

        GIT_FAIL+=( "${GIT_COMMIT//${_GIT_HASH} } ($_GIT_AUTHOR) [$_GIT_HASH]" )
      fi
    else
      __duct_msg e "WTF?!"
      return 1
    fi
  done

  if [[ "$DUCT_GIT_CVC_CHECK_PASS" == true ]]
  then
    for _GIT_PASS in "${GIT_PASS[@]}"
    do
      __duct_msg n "PASS: $_GIT_PASS"
    done
  fi

  if [[ "$DUCT_GIT_CVC_CHECK_FAIL"  == true ]]
  then
    for _GIT_FAIL in "${GIT_FAIL[@]}"
    do
      __duct_msg e "FAIL: $_GIT_FAIL"
    done
    if [[ "${#GIT_FAIL[@]}" -gt 0 ]]
    then
      return 1
    fi
  fi
}
readonly -f __duct_git_cvc_check
