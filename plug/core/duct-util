# vim: set ft=sh syn=bash :
# shellcheck shell=bash

#
# Copyright (C) 2022 Chris 'sh0shin' Frage
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License, version 3,
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#

# duct-util
# Collection of core utilities.

# lower

# deps:
# intl: false
# life: core
# desc: Return string to lower.
# opts: <string>
__duct_lower() {
  local STRING="$1"

  __duct_msg d "$STRING -> ${STRING,,}"

  printf "%b\n" "${STRING,,}"
}
readonly -f __duct_lower

# upper

# deps:
# intl: false
# life: core
# desc: Return string to upper.
# opts: <string>
__duct_upper() {
  local STRING="$1"

  __duct_msg d "$STRING -> ${STRING^^}"

  printf "%b\n" "${STRING^^}"
}
readonly -f __duct_upper

# slug

# deps:
# intl: false
# life: core
# desc: Slugify a string.
# opts: <string>
__duct_slug() {
  local STRING="$1"

  __duct_msg d "$STRING"

  STRING="${STRING,,}"    # lower
  STRING="${STRING// /-}" # whitespace to '-'

  printf "%b\n" "$STRING"
}
readonly -f __duct_slug

# trim

# deps:
# intl: false
# life: core
# desc: Remove leading and trailing whitespaces from string.
# opts: <string>
__duct_trim() {
  local STRING="$1"

  __duct_msg d "$STRING"

  shopt -s extglob
  STRING="${STRING##*([[:space:]])}"
  STRING="${STRING%%*([[:space:]])}"
  shopt -u extglob

  printf "%b\n" "$STRING"
}
readonly -f __duct_trim

# addarray

# deps: duct-array duct-msg
# intl: false
# life: deprecated
# desc: Alias of `duct array add`.
# opts:
__duct_addarray() {
  __duct_msg w "use 'duct array add' instead!"
  __duct_array_add "$@"
}
readonly -f __duct_addarray

# joinarray

# deps: duct-array duct-msg
# intl: false
# life: deprecated
# desc: Alias of `duct array join`.
# opts:
__duct_joinarray() {
  __duct_msg w "use 'duct array join' instead!"
  __duct_array_join "$@"
}
readonly -f __duct_joinarray

# striparray

# deps: duct-array duct-msg
# intl: false
# life: deprecated
# desc: Alias of `duct array strip`.
# opts:
__duct_striparray() {
  __duct_msg w "use 'duct array strip' instead!"
  __duct_array_strip "$@"
}
readonly -f __duct_striparray

# sortarray

# deps: duct-array duct-msg
# intl: false
# life: deprecated
# desc: Alias of `duct array sort`.
# opts:
__duct_sortarray() {
  __duct_msg w "use 'duct array sort' instead!"
  __duct_array_sort "$@"
}
readonly -f __duct_sortarray

# uniquearray

# deps: duct-array duct-msg
# intl: false
# life: deprecated
# desc: Alias of `duct array unique`.
# opts:
__duct_uniquearray() {
  __duct_msg w "use 'duct array unique' instead!"
  __duct_array_unique "$@"
}
readonly -f __duct_uniquearray

# strip

# deps:
# intl: false
# life: core
# desc: Strip elements from a string.
# opts: <strip> <string>
__duct_strip() {
  local IFS=" "
  local -a STRIP
  local -a STRING

  IFS=" " read -r -a STRIP <<< "$1"
  IFS=" " read -r -a STRING <<< "$2"

  __duct_msg d "'${STRIP[*]}' from '${STRING[*]}'"

  for S in "${STRIP[@]}"
  do
    for I in "${!STRING[@]}"
    do
      if [[ "${STRING[I]}" == "$S" ]]
      then
        unset 'STRING[I]'
      fi
    done
  done
  echo "${STRING[*]}"
}
readonly -f __duct_strip

# debase64

# deps: duct-msg
# intl: false
# life: core
# desc: Decode a base64 string to plain-text, or simply output the plain-text input value.
# opts: <string>
__duct_debase64() {
  local DEBASE64
  local DEBASE64_RC=0
  local DEBASE64_STRING="${1:-}"

  if [[ -z "$DEBASE64_STRING" ]]
  then
    __duct_msg e "empty string!"
    return 1
  fi

  set +e
  DEBASE64="$( echo "$DEBASE64_STRING" | base64 -d 2>/dev/null )"
  DEBASE64_RC=$?
  set -e

  if [[ "$DEBASE64_RC" -gt 0 ]]
  then
    __duct_msg d "plain string"
    echo "$DEBASE64_STRING"
  else
    if [[ ! "$DEBASE64" =~ [[:alpha:]] ]]
    then
      __duct_msg d "plain string"
      echo "$DEBASE64_STRING"
    else
      __duct_msg d "base64 string"
      echo "$DEBASE64"
    fi
  fi
}
readonly -f __duct_debase64

# sfile

# Enable/disable masking of content (WARNING!).
declare -g DUCT_SFILE_MASK=${DUCT_SFILE_MASK:-true}

# String used to mask the content.
declare -g DUCT_SFILE_MASK_STRING=${DUCT_SFILE_MASK_STRING:-"[SECRET]"}

# Enable/disable overwriting the file.
declare -g DUCT_SFILE_OVERWRITE=${DUCT_SFILE_OVERWRITE:-false}

# Filename to use.
declare -g DUCT_SFILE_FILENAME=${DUCT_SFILE_FILENAME:-}

# Default file mode.
declare -g DUCT_SFILE_FILEMODE=${DUCT_SFILE_FILEMODE:-0600}

# File content.
declare -g DUCT_SFILE_CONTENT=${DUCT_SFILE_CONTENT:-}

# deps: duct-msg duct-run
# intl: false
# life: core
# desc: Write a file masking the content from messages.
# opts: [filename] [content]
__duct_sfile() {
  local FILE="${1:-"${DUCT_SFILE_FILENAME}"}"
  local CONT="${2:-"${DUCT_SFILE_CONTENT}"}"
  local MASK="$CONT"
  local ROOT

  if [[ -z "$FILE" ]]
  then
    __duct_msg e "no filename!"
    return 1
  fi

  ROOT="$( __duct_dirname "$FILE" )"

  if [[ -s "$FILE" ]]
  then
    if [[ "$DUCT_SFILE_OVERWRITE" == true ]]
    then
      __duct_msg w "$FILE exists, overwriting!"
    else
      __duct_msg w "$FILE exists, not changing!"
      return 0
    fi
  fi

  if [[ "$DUCT_SFILE_MASK" == true ]]
  then
    MASK="$DUCT_SFILE_MASK_STRING"
  else
    MASK="$CONT"
  fi

  if [[ "$DUCT_RUN_SIMULATE" == true ]]
  then
    __duct_msg x "[SIMULATE] creating $FILE with content: $MASK"
  else
    if [[ ! -d "$ROOT" ]]
    then
      __duct_msg d "creating root $ROOT"
      mkdir -p "$ROOT" || return
    fi

    __duct_msg n "creating $FILE with content: $MASK"
    :> "$FILE"
    printf "%s\n" "$CONT" > "$FILE"
    __duct_run chmod "$DUCT_SFILE_FILEMODE" "$FILE"
  fi
}
readonly -f __duct_sfile

# cleanup

# List of directories and files to cleanup (defaults).
declare -a -r _DUCT_CLEANUP_LIST=()

# shellcheck disable=SC2206
# - Preserve empty array
# List of directories and files to cleanup.
declare -g -a DUCT_CLEANUP_LIST=( ${DUCT_CLEANUP_LIST[@]:-${_DUCT_CLEANUP_LIST[@]}} )

# deps: duct-msg duct-run
# intl: false
# life:
# desc: Cleanup and remove a list of directories and files.
# opts: [cleanup-list[@]]
__duct_cleanup() {
  local CLEANUP
  # shellcheck disable=SC2206
  local CLEANUP_LIST=( ${DUCT_CLEANUP_LIST[@]:-$@} )

  if [[ ${#CLEANUP_LIST[@]} -eq 0 ]]
  then
    __duct_msg w "empty cleanup list!"
    return 0
  fi

  for CLEANUP in "${CLEANUP_LIST[@]}"
  do
    if [[ -d "${CLEANUP:?}" ]]
    then
      __duct_msg n "removing dir ${CLEANUP:?}"
      __duct_run rm -fr "${CLEANUP:?}"

    elif [[ -f "${CLEANUP:?}" ]]
    then
      __duct_msg n "removing file ${CLEANUP:?}"
      __duct_run rm -f "${CLEANUP:?}"
    else
      __duct_msg w "${CLEANUP:?} not found!"
    fi
  done
}
readonly -f __duct_cleanup

# random

# Random character list (defaults).
declare -r -a _DUCT_RANDOM_CHARS=(
  "ABCDEFGHJKLMNPQRSTUVWX"
  "abcdefghijkmnpqrstuvwx"
  "123456789"
  "!$%,."
)

# Random character list.
declare -g -a DUCT_RANDOM_CHARS=( "${DUCT_RANDOM_CHARS[@]:-${_DUCT_RANDOM_CHARS[@]}}" )

# Random string length.
declare -g -i DUCT_RANDOM_LENGTH=${DUCT_RANDOM_LENGTH:-16}

# deps: duct-msg
# intl: false
# life: core
# desc: Create a random string from given character list.
# opts: [length]
__duct_random() {
  local -i RANDOM_LEN="${1:-${DUCT_RANDOM_LENGTH}}"

  local -a RANDOM_LIST=()
  local RANDOM_STR
  local RANDOM_CHARS

  RANDOM_CHARS="${DUCT_RANDOM_CHARS[*]}"
  RANDOM_CHARS="${RANDOM_CHARS// }"

  for (( IDX=0; IDX<${#RANDOM_CHARS}; IDX++ ))
  do
    RANDOM_LIST+=( "${RANDOM_CHARS:$IDX:1}" )
  done

  __duct_msg d "$RANDOM_LEN chars out of '$RANDOM_CHARS'"

  for (( IDX=0; IDX<RANDOM_LEN; IDX++ ))
  do
    if [[ "$DUCT_BASH_SRANDOM" == true ]]
    then
      RANDOM_STR+="${RANDOM_LIST[$(( SRANDOM % ${#RANDOM_LIST[@]} ))]}"
    else
      RANDOM_STR+="${RANDOM_LIST[$(( RANDOM % ${#RANDOM_LIST[@]} ))]}"
    fi
  done

  printf "%b\n" "$RANDOM_STR"
}
readonly -f __duct_random

# tmpgen

# Prefix of tmp.
declare -g DUCT_TMPGEN_PREFIX="${DUCT_TMPGEN_PREFIX:-"duct-"}"

# Tmp directory.
declare -g DUCT_TMPGEN_PATH="${DUCT_TMPGEN_PATH:-${TMPDIR:-"/tmp"}}"

# Length of random part.
declare -g DUCT_TMPGEN_LENGTH="${DUCT_TMPGEN_LENGTH:-9}"

# deps:
# intl: false
# life: core
# desc: Generate a temporary path, without creating it.
# opts: [prefix] [path]
__duct_tmpgen() {
  local TMP_PREFIX="${1:-"$DUCT_TMPGEN_PREFIX"}"
  local TMP_PATH="${2:-"$DUCT_TMPGEN_PATH"}"
  local TMP_GEN
  local TMP_RC=0

  TMP_GEN="${TMP_PATH}/${TMP_PREFIX}$(
    export DUCT_RANDOM_CHARS=(
      "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      "abcdefghijklmnopqrstuvwxyz"
      "0123456789"
    )
    __duct_random "$DUCT_TMPGEN_LENGTH"
  )" || TMP_RC=$?

  printf "%b\n" "$TMP_GEN"
}
readonly -f __duct_tmpgen

# mktmpdir

# Prefix.
declare -g DUCT_MKTMPDIR_PREFIX="${DUCT_MKTMPDIR_PREFIX:-"duct-"}"

# Tmp path.
declare -g DUCT_MKTMPDIR_PATH="${DUCT_MKTMPDIR_PATH:-${TMPDIR:-"/tmp"}}"

# Mode of directory.
declare -g DUCT_MKTMPDIR_MODE="${DUCT_MKTMPDIR_MODE:-0700}"

# deps: duct-msg duct-run
# intl: false
# life: core
# desc: Create a temporary directory using `duct tmpgen`.
# opts: [prefix] [path]
__duct_mktmpdir() {
  local TMP_PREFIX="${1:-"$DUCT_MKTMPDIR_PREFIX"}"
  local TMP_PATH="${2:-"$DUCT_MKTMPDIR_PATH"}"
  local TMP_DIR
  local TMP_RC=0

  TMP_DIR="$( __duct_tmpgen "$TMP_PREFIX" "$TMP_PATH" )"
  __duct_msg n "creating ${TMP_DIR}"
  __duct_run mkdir -m "$DUCT_MKTMPDIR_MODE" -p "$TMP_DIR" || TMP_RC=$?
  printf "%b\n" "$TMP_DIR"
  return $TMP_RC
}
readonly -f __duct_mktmpdir

# mktmpfile

# Prefix
declare -g DUCT_MKTMPFILE_PREFIX="${DUCT_MKTMPDIR_PREFIX:-"duct-"}"

# Tmp path.
declare -g DUCT_MKTMPFILE_PATH="${DUCT_MKTMPFILE_PATH:-${TMPDIR:-"/tmp"}}"

# Mode of file
declare -g DUCT_MKTMPFILE_MODE="${DUCT_MKTMPFILE_MODE:-0600}"

# deps: duct-msg duct-run
# intl: false
# life: core
# desc: Create a temporay file using `duct tmpgen`.
# opts: [prefix] [path]
__duct_mktmpfile() {
  local TMP_PREFIX="${1:-"$DUCT_MKTMPFILE_PREFIX"}"
  local TMP_PATH="${2:-"$DUCT_MKTMPFILE_PATH"}"
  local TMP_FILE
  local TMP_RC=0

  TMP_FILE="$( __duct_tmpgen "$TMP_PREFIX" "$TMP_PATH" )"
  __duct_msg n "creating ${TMP_FILE}"
  (
    __duct_run touch "$TMP_FILE" || TMP_RC=$?
    __duct_run chmod "$DUCT_MKTMPFILE_MODE" "$TMP_FILE"
  ) || TMP_RC=$?
  printf "%b\n" "$TMP_FILE"
  return $TMP_RC
}
readonly -f __duct_mktmpfile

# find count

# deps: duct-msg
# intl: false
# life: core
# desc: Find files and directories returning count.
# opts: <path> <@file-directory>
__duct_find_count() {
  local COUNT_ROOT="${1:-$PWD}"
  shift
  local -a COUNT_MATCH=( "$@" )

  local MATCH
  local COUNT=0

  for MATCH in "${COUNT_MATCH[@]}"
  do
    _PATH="${COUNT_ROOT}/${MATCH}"
    if [[ -e "$_PATH" ]]
    then
      if [[ -f "$_PATH" ]]
      then
        __duct_msg d "file found $_PATH"
        (( COUNT+=1 ))
      elif [[ -d "$_PATH" ]]
      then
        __duct_msg d "directory found $_PATH"
        (( COUNT+=1 ))
      fi
    fi
    unset _PATH
  done
  echo "$COUNT"
}
readonly -f __duct_find_count

# bin check

# List of binaries to check (defaults).
declare -a _DUCT_BIN_CHECK_LIST=()

# shellcheck disable=SC2206
# List of binaries to check.
declare -g -a DUCT_BIN_CHECK_LIST=( ${DUCT_BIN_CHECK_LIST[@]:-${_DUCT_BIN_CHECK_LIST[@]}} )

# deps: duct-msg
# intl: false
# life: core
# desc: Check a list of binaries/commands for availibility.
# opts: [bin-list[@]]
__duct_bin_check() {
  local -a BIN_LIST=( "${@:-${DUCT_BIN_CHECK_LIST[@]}}" )
  local BIN_CMD
  local BIN_PATH
  local BIN_RC=0
  local BIN_HELP_RC=0

  if [[ ${#BIN_LIST[@]} -eq 0 ]]
  then
    __duct_msg w "empty binary list!"
  fi

  for BIN_CMD in "${BIN_LIST[@]}"
  do
    BIN_PATH=$(type -P "$BIN_CMD" || :)

    if [[ -n "$BIN_PATH" ]]
    then
      command "$BIN_PATH" --help >/dev/null 2>&1 || BIN_HELP_RC=$?

      case "$BIN_HELP_RC" in
        0)
          __duct_msg d "'$BIN_PATH' found"
        ;;
        127)
          __duct_msg w "'$BIN_PATH' found, but command returned 127 (not found)!"
        ;;
        *)
          __duct_msg d "'$BIN_PATH' found ($BIN_HELP_RC)"
        ;;
      esac
    else
      __duct_msg e "'$BIN_CMD' not found!"
      (( BIN_RC+=1 ))
    fi
  done

  if [[ "$BIN_RC" -gt 0 ]]
  then
    return 1
  else
    return 0
  fi
}
readonly -f __duct_bin_check

# var check

# List of variables to check (defaults).
declare -a _DUCT_VAR_CHECK_LIST=()

# shellcheck disable=SC2206
# List of variables to check.
declare -g -a DUCT_VAR_CHECK_LIST=( ${DUCT_VAR_CHECK_LIST[@]:-${_DUCT_VAR_CHECK_LIST[@]}} )

# deps: duct-msg
# intl: false
# life: core
# desc: Check if variables are present and set.
# opts: [var[@]]
__duct_var_check() {
  local -a VAR_LIST=( "${@:-${DUCT_VAR_CHECK_LIST[@]}}" )
  local VAR
  local VAR_RC=0

  set +u
  for VAR in "${VAR_LIST[@]}"
  do
    if [[ -n "${!VAR}" ]]
    then
      if [[ "$VAR" =~ (PASS|SECRET|TOKEN) ]]
      then
        __duct_msg d "$VAR set ([HIDDEN])"
      else
        __duct_msg d "$VAR set (${!VAR})"
      fi
    else
      __duct_msg e "$VAR unset!"
      (( VAR_RC+=1 ))
    fi
  done
  set -u

  if [[ "$VAR_RC" -gt 0 ]]
  then
    return 1
  fi
}
readonly -f __duct_var_check

# ver check

# deps: duct-msg
# intl: true
# life: core
# desc: Check minimal required version.
# opts: <command> <minimal-version> <match>
__duct_ver_check() {
  local VER_CMD="$1"
  local VER_MIN="$2"
  local VER_MATCH="$3"

  local -a VER_MININFO
  local -a VER_VERSINFO
  local VER_RC=0
  local VER_VERSION

  IFS="." read -r -a VER_MININFO <<< "$VER_MIN"

  # shellcheck disable=SC2046
  set -- $( command $VER_CMD --version )
  VER_VERSION="${!VER_MATCH}"

  # remove *-
  VER_VERSION="${VER_VERSION#*-}"

  # accept master|main version
  if [[ ! "$VER_VERSION" =~ (master|main) ]]
  then
    IFS="." read -r -a VER_VERSINFO <<< "$VER_VERSION"

    if [[ "${VER_VERSINFO[0]}" -lt "${VER_MININFO[0]}" ]]
    then
      (( VER_RC+=1 ))
    elif [[ "${VER_VERSINFO[0]}" -eq "${VER_MININFO[0]}" ]] && \
         [[ "${VER_VERSINFO[1]}" -lt "${VER_MININFO[1]}" ]]
    then
      (( VER_RC+=1 ))
    fi
  fi

  if [[ "$VER_RC" -gt 0 ]]
  then
    __duct_msg e "$VER_CMD version $VER_VERSION is unsupported!"
    __duct_msg e "minimal required version $VER_MIN"
    return 1
  else
    __duct_msg d "$VER_CMD version $VER_VERSION"
  fi
}
readonly -f __duct_ver_check

# textract

# Filename to extract text from.
declare -g DUCT_TEXTRACT_FILENAME=""

# Marker begin.
declare -g DUCT_TEXTRACT_MARKER_BEGIN=""

# Marker end.
declare -g DUCT_TEXTRACT_MARKER_END=""

# deps: duct-msg
# intl: false
# life:
# desc: Extract text between two markers.
# opts: [filename] [marker-begin] [marker-end]
__duct_textract() {
  local TEXT_FILE="${1:-"$DUCT_TEXTRACT_FILENAME"}"
  local TEXT_BEGIN="${2:-"$DUCT_TEXTRACT_MARKER_BEGIN"}"
  local TEXT_END="${3:-"$DUCT_TEXTRACT_MARKER_END"}"
  local -a TEXT_CONTENT
  local TEXT_LINE
  local TEXT_PRINT=0
  local TEXT_ERROR=0

  if [[ -z "$TEXT_FILE" ]]
  then
    __duct_msg e "no file!"
    (( TEXT_ERROR+=1 ))
  fi

  if [[ -z "$TEXT_BEGIN" ]]
  then
    __duct_msg e "no marker begin!"
    (( TEXT_ERROR+=1 ))
  fi

  if [[ -z "$TEXT_END" ]]
  then
    __duct_msg e "no marker end!"
    (( TEXT_ERROR+=1 ))
  fi

  if [[ $TEXT_ERROR -gt 0 ]]
  then
    return 1
  fi

  if [[ ! -f "$TEXT_FILE" ]]
  then
    __duct_msg d "using variable input"
    readarray -t TEXT_CONTENT <<< "$TEXT_FILE"
  else
    __duct_msg d "using file $TEXT_FILE"
    readarray -t TEXT_CONTENT < "$TEXT_FILE"
  fi

  for TEXT_LINE in "${TEXT_CONTENT[@]}"
  do
    if [[ "$TEXT_PRINT" -eq 1 ]] && [[ "$TEXT_LINE" != "$TEXT_END" ]]
    then
      echo "$TEXT_LINE"
    fi

    if [[ $TEXT_LINE == "$TEXT_BEGIN" ]]
    then
      __duct_msg d "found $TEXT_BEGIN"
      TEXT_PRINT=1
    fi

    if [[ $TEXT_LINE == "$TEXT_END" ]]
    then
      __duct_msg d "found $TEXT_END"
      TEXT_PRINT=0
    fi
  done
}
readonly -f __duct_textract

# textinject

# Filename to extract text from.
declare -g DUCT_TEXTINJECT_FILENAME=""

# Marker begin.
declare -g DUCT_TEXTINJECT_MARKER_BEGIN=""

# Marker end.
declare -g DUCT_TEXTINJECT_MARKER_END=""

# Text to inject.
declare -g DUCT_TEXTINJECT_TEXT=""

# deps: duct-msg
# intl: false
# life: core
# desc: Extract text between two markers.
# opts: [filename] [marker-begin] [marker-end]
__duct_textinject() {
  local TEXT_FILE="${1:-"$DUCT_TEXTINJECT_FILENAME"}"
  local TEXT_BEGIN="${2:-"$DUCT_TEXTINJECT_MARKER_BEGIN"}"
  local TEXT_END="${3:-"$DUCT_TEXTINJECT_MARKER_END"}"
  local TEXT_INJECT="${4:-"$DUCT_TEXTINJECT_TEXT"}"

  local -a TEXT_ALL=()
  local -a TEXT_CONTENT
  local -a TEXT_POST=()
  local -a TEXT_PRE=()
  local TEXT_BEGIN_LINE=0
  local TEXT_END_LINE=0
  local TEXT_ERROR=0
  local TEXT_LINE

  if [[ -z "$TEXT_FILE" ]]
  then
    __duct_msg e "no file!"
    (( TEXT_ERROR+=1 ))
  fi

  if [[ ! -e "$TEXT_FILE" ]]
  then
    __duct_msg e "$TEXT_FILE not found!"
    (( TEXT_ERROR+=1 ))
  fi

  if [[ -z "$TEXT_BEGIN" ]]
  then
    __duct_msg e "no marker begin!"
    (( TEXT_ERROR+=1 ))
  fi

  if [[ -z "$TEXT_END" ]]
  then
    __duct_msg e "no marker end!"
    (( TEXT_ERROR+=1 ))
  fi

  if [[ -z "$TEXT_INJECT" ]]
  then
    __duct_msg e "no text!"
    (( TEXT_ERROR+=1 ))
  fi

  if [[ $TEXT_ERROR -gt 0 ]]
  then
    return 1
  fi

  __duct_msg d "using $TEXT_FILE"
  mapfile -t -n 0 TEXT_CONTENT < "$TEXT_FILE"

  for TEXT_LINE in "${!TEXT_CONTENT[@]}"
  do
    if [[ "${TEXT_CONTENT[$TEXT_LINE]}" == "$TEXT_BEGIN" ]]
    then
      __duct_msg d "found $TEXT_BEGIN (${TEXT_FILE}:$(( TEXT_LINE + 1)))"
      TEXT_BEGIN_LINE=$TEXT_LINE
    fi

    if [[ "${TEXT_CONTENT[$TEXT_LINE]}" == "$TEXT_END" ]]
    then
      __duct_msg d "found $TEXT_END (${TEXT_FILE}:$(( TEXT_LINE + 1)))"
      TEXT_END_LINE=$TEXT_LINE
    fi
  done

  __duct_msg d "injecting text: $TEXT_INJECT"
  TEXT_PRE=( "${TEXT_CONTENT[@]:0:$(( TEXT_BEGIN_LINE + 1 ))}" )
  TEXT_POST=( "${TEXT_CONTENT[@]:$TEXT_END_LINE}" )
  TEXT_ALL=(
    "${TEXT_PRE[@]}"
    "$TEXT_INJECT"
    ""
    "${TEXT_POST[@]}"
  )

  __duct_msg d "writing file: $TEXT_FILE"
  printf "%s\n" "${TEXT_ALL[@]}" > "$TEXT_FILE"
}
readonly -f __duct_textinject

# compversion

# deps:
# intl: false
# life:
# desc: Compare two semantic versions, return newer or equal.
# opts: <version1> <version2>
__duct_compversion() {
  local VERSION_1="${1:-}"
  local VERSION_2="${2:-}"

  local VERSION_1_PREFIX=""
  local VERSION_2_PREFIX=""

  local IFS=.
  local I

  if [[ "$VERSION_1" =~ ^v ]]
  then
    VERSION_1="${VERSION_1//v}"
    VERSION_1_PREFIX="v"
  fi

  if [[ "$VERSION_2" =~ ^v ]]
  then
    VERSION_2="${VERSION_2//v}"
    VERSION_2_PREFIX="v"
  fi

  # to array
  read -ra VERSION_1 <<< "$VERSION_1"
  read -ra VERSION_2 <<< "$VERSION_2"

  for ((I=${#VERSION_1[@]}; I<${#VERSION_2[@]}; I++))
  do
    VERSION_1[I]=0
  done

  for ((I=0; I<${#VERSION_1[@]}; I++))
  do
    if [[ -z ${VERSION_2[I]} ]]
    then
      VERSION_2[I]=0
    fi

    if ((10#${VERSION_1[I]} > 10#${VERSION_2[I]}))
    then
      __duct_msg d "${VERSION_1_PREFIX}${VERSION_1[*]} > ${VERSION_2_PREFIX}${VERSION_2[*]}"
      echo "${VERSION_1_PREFIX}${VERSION_1[*]}"
      return
    fi

    if ((10#${VERSION_1[I]} < 10#${VERSION_2[I]}))
    then
      __duct_msg d "${VERSION_1_PREFIX}${VERSION_1[*]} < ${VERSION_2_PREFIX}${VERSION_2[*]}"
      echo "${VERSION_2_PREFIX}${VERSION_2[*]}"
      return
    fi
  done

  __duct_msg d "${VERSION_1_PREFIX}${VERSION_1[*]} = ${VERSION_2_PREFIX}${VERSION_2[*]}"
  echo "${VERSION_1_PREFIX}${VERSION_1[*]}"
  return
}
readonly -f __duct_compversion

# urlinfo

# desc: Associative array of URL parts.
declare -g -x -A DUCT_URLINFO=()

# deps: duct-msg
# intl: false
# life: beta
# desc: Explode a URL into parts and set `DUCT_URLINFO` (`scheme`, `host`, and `path` is supported).
# opts: <url>
__duct_urlinfo() {
  local URL="${1:-""}"

  if [[ -z "$URL" ]]
  then
    __duct_msg e "no url!"
    return 1
  fi

  URL_SCHEME="${URL%%//*}"
  URL_SCHEME="${URL_SCHEME//:}"

  URL_AUTHPATH="${URL#*//}"

  URL_HOST="${URL_AUTHPATH%%/*}"
  URL_PATH="${URL_AUTHPATH#*/}"

  if [[ "$URL_PATH" == "$URL_HOST" ]]
  then
    URL_PATH="/"
  fi

  __duct_msg d "set scheme: '$URL_SCHEME'"
  DUCT_URLINFO["scheme"]="$URL_SCHEME"

  __duct_msg d "set host: '$URL_HOST'"
  DUCT_URLINFO["host"]="$URL_HOST"

  __duct_msg d "set path: '$URL_PATH'"
  DUCT_URLINFO["path"]="$URL_PATH"
}
readonly -f __duct_urlinfo

# urlsplit

# Array of URL splits.
declare -g -x -a DUCT_URLSPLIT=()

# deps: duct-msg
# intl: false
# life: beta
# desc: Split a URL into parts and set `DUCT_URLSPLIT`.
# opts: <url>
__duct_urlsplit() {
  local URL="${1:-}"

  if [[ -z "$URL" ]]
  then
    __duct_msg e "no url!"
    return 1
  fi

  IFS=" " read -r -a DUCT_URLSPLIT <<< "${URL//\// }"
}
readonly -f __duct_urlsplit

# ostype

# Mapping of ostype source=destination (defaults).
declare -a -r _DUCT_OSTYPE_MAP=()

# Exported ostype mapping results (set at runtime).
declare -g -x DUCT_OSTYPE="${DUCT_OSTYPE:-}"

# Exported ostype extra information (set at runtime).
declare -g -x DUCT_OSTYPE_EXTRA="${DUCT_OSTYPE_EXTRA:-}"

# shellcheck disable=SC2206
# Mapping of ostype source=destination.
declare -g -a DUCT_OSTYPE_MAP=( ${DUCT_OSTYPE_MAP[@]:-${_DUCT_OSTYPE_MAP[@]}} )

# deps: duct-msg
# intl: false
# life: core
# desc: Process ostype mapping and set matching ostype to `DUCT_OSTYPE`.
# opts:
__duct_ostype() {
  local MAP
  local SRC
  local DST
  local _OSTYPE="$OSTYPE"

  # name-extra
  if [[ "$_OSTYPE" =~ ([a-z]+)-?([a-z]+)?$ ]]
  then
    DUCT_OSTYPE_EXTRA="${BASH_REMATCH[-1]}"
    _OSTYPE="${BASH_REMATCH[-2]}"

  # nameversion
  elif [[ "$_OSTYPE" =~ ([a-z]+)([0-9.]+)?$ ]]
  then
    DUCT_OSTYPE_EXTRA="${BASH_REMATCH[-1]}"
    _OSTYPE="${BASH_REMATCH[-2]}"
  fi

  if [[ "${#DUCT_OSTYPE_MAP[@]}" -eq 0 ]]
  then
    export DUCT_OSTYPE="$_OSTYPE"
    return
  fi

  __duct_msg d "$_OSTYPE mapping '${DUCT_OSTYPE_MAP[*]}'"

  for MAP in "${DUCT_OSTYPE_MAP[@]}"
  do
    SRC="${MAP%%=*}"
    DST="${MAP##*=}"

    if [[ "$_OSTYPE" == "$SRC" ]]
    then
      _OSTYPE="$DST"
    fi
  done

  export DUCT_OSTYPE="$_OSTYPE"
}
readonly -f __duct_ostype

# hosttype

# Mapping of hosttype source=destination (defaults).
declare -a -r _DUCT_HOSTTYPE_MAP=()

# Exported hosttype mapping results (set at runtime).
declare -g -x DUCT_HOSTTYPE=""

# shellcheck disable=SC2206
# Mapping of hosttype source=destination.
declare -g -a DUCT_HOSTTYPE_MAP=( ${DUCT_HOSTTYPE_MAP[@]:-${_DUCT_HOSTTYPE_MAP[@]}} )

# Exported hosttype common variants.
declare -g -x -a DUCT_HOSTTYPE_COMMON=()

# deps: duct-msg
# intl: false
# life: core
# desc: Process hosttype mapping and set matching hosttype to `DUCT_HOSTTYPE`.
# opts:
__duct_hosttype() {
  local DST
  local MAP
  local SRC
  local _HOSTTYPE="$HOSTTYPE"

  case "$_HOSTTYPE"
  in
    aarch64)  DUCT_HOSTTYPE_COMMON+=( "arm64" ) ;;
    amd64)    DUCT_HOSTTYPE_COMMON+=( "x86_64" ) ;;
    arm64)    DUCT_HOSTTYPE_COMMON+=( "aarch64" ) ;;
    x86_64)   DUCT_HOSTTYPE_COMMON+=( "amd64" ) ;;

    arm*)     DUCT_HOSTTYPE_COMMON+=( "arm" ) ;;
  esac

  DUCT_HOSTTYPE_COMMON+=( "$_HOSTTYPE" )

  if [[ "${#DUCT_HOSTTYPE_MAP[@]}" -eq 0 ]]
  then
    export DUCT_HOSTTYPE="$_HOSTTYPE"
    return
  fi

  __duct_msg d "$_HOSTTYPE mapping '${DUCT_HOSTTYPE_MAP[*]}'"

  for MAP in "${DUCT_HOSTTYPE_MAP[@]}"
  do
    SRC="${MAP%%=*}"
    DST="${MAP##*=}"

    if [[ "$_HOSTTYPE" == "$SRC" ]]
    then
      _HOSTTYPE="$DST"
    fi
  done

  export DUCT_HOSTTYPE="$_HOSTTYPE"
}
readonly -f __duct_hosttype

# unpack

# deps: duct-gnu duct-msg duct-run
# intl: true
# life:
# desc: Unpack files from an archive.
# opts:
__duct_unpack() {
  local ARCHIVE="$1"
  shift
  local DIR="$1"
  shift
  local MODE="$1"
  shift
  local -a FILES=( "$@" )
  local FILE
  local SRC_FILE
  local DST_FILE

  for FILE in "${FILES[@]}"
  do
    SRC_FILE="${FILE%%:*}"
    DST_FILE="${FILE##*:}"

    local STRIP_PATH=0
    local -a EXTRA_OPTS=()
    local TYPE

    __duct_msg n "unpacking $SRC_FILE from $ARCHIVE to ${DIR}/${DST_FILE}"

    case "$ARCHIVE" in
      *.tar.gz|*.tar.xz|*.tgz|*.txz)
        # get / count
        STRIP_PATH="${FILE//[^\/]}"
        STRIP_PATH="${#STRIP_PATH}"

        if [[ $STRIP_PATH -ge 1 ]]
        then
          EXTRA_OPTS+=( --strip-components="$STRIP_PATH" --wildcards )
        fi
        __duct_gnu_tar -xf "$ARCHIVE" -C "$DIR" "${EXTRA_OPTS[@]}" "$SRC_FILE"
      ;;

      *.zip)
        __duct_run unzip -oqq "$ARCHIVE" "$SRC_FILE" -d "$DIR" "${EXTRA_OPTS[@]}"
      ;;

      *)
        TYPE="$( file -b --mime-type "$ARCHIVE" )"

        if [[ "$TYPE" =~ (executable|binary) ]]
        then
          __duct_run install -m "$MODE" "$ARCHIVE" "${DIR}/${DST_FILE}"
        else
          __duct_msg e "unsuported archive type $ARCHIVE"
          return 1
        fi
      ;;
    esac

    if [[ "$STRIP_PATH" -ge 1 ]]
    then
      SRC_FILE="${SRC_FILE##*/}"
    fi

    if [[ "$SRC_FILE" != "$DST_FILE" ]]
    then
      # shellcheck disable=SC2086
      __duct_run mv ${DIR}/${SRC_FILE} "${DIR}/${DST_FILE}"
    fi

    __duct_run chmod "$MODE" "${DIR}/${DST_FILE}"
  done

  __duct_run rm -f "${ARCHIVE:?}"
}
readonly -f __duct_unpack

# sleep random

# deps: duct-msg
# intl: false
# life: core
# desc: Sleep random seconds (default max 5, min 1 second).
# opts: [sleep-max] [sleep-min]
__duct_sleep_random() {
  local SLEEP_MAX="${1:-5}"
  local SLEEP_MIN="${2:-1}"

  local SLEEP_RANDOM=0

  while [[ "$SLEEP_RANDOM" -lt "$SLEEP_MIN" ]]
  do
    SLEEP_RANDOM="$(( RANDOM % SLEEP_MAX + 1 ))"
  done

  __duct_msg d "sleep $SLEEP_RANDOM of $SLEEP_MIN/$SLEEP_MAX second(s)"
  sleep "$SLEEP_RANDOM"
}
readonly -f __duct_sleep_random

# sgrep

# List of files to use (defaults).
declare -r -a _DUCT_SGREP_FILES=()

# Bash regex compatible match.
declare -g DUCT_SGREP_MATCH="${DUCT_SGREP_MATCH:-}"

# shellcheck disable=SC2206
# List of files to use (if empty stdin is used).
declare -g -a DUCT_SGREP_FILES=( ${DUCT_SGREP_FILES[@]:-${_DUCT_SGREP_FILES[@]}} )

# Return value 'match' or 'line' number.
declare -g DUCT_SGREP_RETURN="${DUCT_SGREP_RETURN:-"match"}"

# deps: duct-msg
# intl: false
# life: core
# desc: Simple grep in pure Bash.
# opts: <match> [file(s)]
__duct_sgrep() {
  local SGREP_MATCH="${1:-$DUCT_SGREP_MATCH}"
  shift || :
  # shellcheck disable=SC2206
  local -a SGREP_FILES=( ${@:-${DUCT_SGREP_FILES[@]}} )

  if [[ -z "$SGREP_MATCH" ]]
  then
    __duct_msg e "no match specified!"
    return 1
  fi

  local -a SGREP_DATA
  local -a SGREP_FOUND=()
  local SGREP_FILE
  local SGREP_LINE

  ___duct_sgrep() {
    for SGREP_LINE in "${!SGREP_DATA[@]}"
    do
      if [[ "${SGREP_DATA[$SGREP_LINE]}" =~ $SGREP_MATCH ]]
      then
        if [[ "$DUCT_SGREP_RETURN" == "match" ]]
        then
          SGREP_FOUND+=( "${SGREP_DATA[$SGREP_LINE]}" )

        elif [[ "$DUCT_SGREP_RETURN" == "line" ]]
        then
          SGREP_FOUND+=( "$(( SGREP_LINE + 1 ))" )
        fi
      fi
    done
  }
  readonly -f ___duct_sgrep

  if [[ "${#SGREP_FILES[@]}" -lt 1 ]]
  then
    readarray -t -n 0 SGREP_DATA
    ___duct_sgrep
  else
    for SGREP_FILE in "${SGREP_FILES[@]}"
    do
      mapfile -t -n 0 SGREP_DATA < "$SGREP_FILE"
      ___duct_sgrep
    done
  fi

  if [[ "${#SGREP_FOUND[@]}" -ge 1 ]]
  then
    printf "%b\n" "${SGREP_FOUND[@]}"
  fi
}
readonly -f __duct_sgrep

# grep

# deps: duct-msg duct-gnu
# intl: false
# life: deprecated
# desc: Alias of `duct gnu grep`.
# opts: <grep-options>
__duct_grep() {
  __duct_msg w "use 'duct gnu grep' instead!"
  __duct_gnu_grep "$@"
}
readonly -f __duct_grep

# sed

# deps: duct-msg duct-gnu
# intl: false
# life: deprecated
# desc: Alias of `duct gnu sed`.
# opts: <sed-options>
__duct_sed() {
  __duct_msg w "use 'duct gnu sed' instead!"
  __duct_gnu_sed "$@"
}
readonly -f __duct_sed
