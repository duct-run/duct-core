# vim: set ft=sh syn=bash :
# shellcheck shell=bash

#
# Copyright (C) 2022-2023 Chris 'sh0shin' Frage
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License, version 3,
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#

# duct-core
# The duct core functions.

# internal

# deps: duct-msg
# intl: true
# life: core
# desc: Check duct internal source.
# opts:
__duct_intl() {
  local INTL_FUNC=""
  local INTL_RUN=0
  local INTL_SRC

  for INTL_SRC in "${FUNCNAME[@]}"
  do
    if [[ "$INTL_SRC" == "source" ]]
    then
      INTL_RUN=1
    fi
  done

  if [[ "$INTL_RUN" -eq 0 ]]
  then
    INTL_FUNC="${FUNCNAME[1]}"
    INTL_FUNC="${INTL_FUNC/#__}"
    INTL_FUNC="${INTL_FUNC//_/ }"

    __duct_msg e "'$INTL_FUNC' internal only!"
    return 1
  fi
}
readonly -f __duct_intl

# env

# Enable/disbale environment processing.
declare -g DUCT_ENV_ENABLE="${DUCT_ENV_ENABLE:-true}"

# Enable/disbale environment debug messages.
declare -g DUCT_ENV_QUIET="${DUCT_ENV_QUIET:-false}"

# deps: duct-msg
# intl: true
# life: core
# desc: Show any user duct environment configuration.
# opts:
__duct_env() {
  __duct_intl

  local -a ENV_USER
  local ENV_ITEM

  local ENV_MSG
  local ENV_VAL
  local ENV_VAR

  if [[ "$DUCT_ENV_ENABLE" != true ]]
  then
    return
  fi

  readarray -t ENV_USER < <( ( set -x; env; set +x ) 2>&1 )

  for ENV_ITEM in "${ENV_USER[@]}"
  do
    if [[ "$ENV_ITEM" =~ (DUCT_[A-Z0-9_]+)=([[:alnum:][:punct:][:blank:]]+)? ]]
    then
      ENV_VAR="${BASH_REMATCH[1]}"
      ENV_VAL="${BASH_REMATCH[2]}"
      ENV_VAL="${ENV_VAL//"'"}"
      ENV_MSG="$ENV_VAL"

      if [[ "$ENV_VAR" =~ (TOKEN|SECRET|PASS) ]]
      then
        ENV_MSG="[HIDDEN]"
      fi

      if [[ "$DUCT_ENV_QUIET" != true ]]
      then
        __duct_msg d "${ENV_VAR}=${ENV_MSG}"
      fi
    fi
  done
}
readonly -f __duct_env

# conf

# Enable/disbale processing config.
declare -g DUCT_CONF_ENABLE="${DUCT_CONF_ENABLE:-true}"

# Enable/disbale config debug messages.
declare -g DUCT_CONF_QUIET="${DUCT_CONF_QUIET:-false}"

# Configuration file search list (internal).
declare -r -a _DUCT_CONF_FILES=(
  "${HOME}/.config/duct/config"
  "${HOME}/.config/duct/env"
  "${HOME}/.ductconfig"
  "${HOME}/.ductconf"
  "${HOME}/.ductenv"
)

# deps: duct-msg
# intl: true
# life: core
# desc: Read and process duct environment configuration.
# opts:
__duct_conf() {
  __duct_intl

  local -a CONF_ENV
  local CONF_FILE
  local CONF_ITEM

  local CONF_ARR
  local CONF_KEY
  local CONF_MSG
  local CONF_VAL
  local CONF_VAR

  if [[ "$DUCT_CONF_ENABLE" != true ]]
  then
    return
  fi

  for CONF_FILE in "${_DUCT_CONF_FILES[@]}"
  do
    if [[ -s "$CONF_FILE" ]]
    then

      if [[ "$DUCT_CONF_QUIET" != true ]]
      then
        __duct_msg d "$CONF_FILE"
      fi

      # shellcheck disable=SC1090
      readarray -t CONF_ENV < <( ( set -x +u; source "$CONF_FILE"; set +x -u ) 2>&1 )

      for CONF_ITEM in "${CONF_ENV[@]}"
      do
        if [[ "$CONF_ITEM" =~ (DUCT_[A-Z_]+)(\[[[:alnum:][:punct:][:blank:]]+\])?=([[:alnum:][:punct:][:blank:]]+) ]]
        then
          CONF_VAR="${BASH_REMATCH[1]}"

          CONF_KEY="${BASH_REMATCH[2]}"
          CONF_ARR="$CONF_KEY"
          CONF_ARR="${CONF_ARR//\[}"
          CONF_ARR="${CONF_ARR//\]}"
          CONF_ARR="${CONF_ARR//\"}"

          CONF_VAL="${BASH_REMATCH[3]}"
          CONF_VAL="${CONF_VAL/#\'}"
          CONF_VAL="${CONF_VAL/%\'}"

          CONF_MSG="$CONF_VAL"

          if [[ "$CONF_VAR" =~ (TOKEN|SECRET|PASS) ]] || [[ "$CONF_KEY" =~ (TOKEN|SECRET|PASS) ]]
          then
            CONF_MSG="[HIDDEN]"
          fi

          if [[ "$DUCT_CONF_QUIET" != true ]]
          then
            __duct_msg d "${CONF_VAR}${CONF_KEY}=${CONF_MSG}"
          fi

          # indexed array specified
          if [[ "$CONF_KEY" =~ (\[[0-9]+\]) ]]
          then
            declare -g -a "$CONF_VAR"
            declare -g -a "${CONF_VAR}[$CONF_ARR]=${CONF_VAL}"

          # associative array
          elif [[ "$CONF_KEY" =~ (\[[[:alnum:][:punct:][:blank:]]+\]) ]]
          then
            declare -g -A "$CONF_VAR"
            declare -g -A "${CONF_VAR}[$CONF_ARR]=${CONF_VAL}"

          # indexed array
          elif [[ "$CONF_VAL" =~ ^(\()([[:alnum:][:punct:][:blank:]]+)(\))$ ]]
          then
            CONF_VAL="${BASH_REMATCH[2]}"
            declare -g -a "${CONF_VAR}=( $CONF_VAL )"

          # integer
          elif [[ "$CONF_VAL" =~ ^(0|[1-9]([0-9]+)?)$ ]]
          then
            declare -g -i "${CONF_VAR}=${CONF_VAL}"
          else
            declare -g "${CONF_VAR}=${CONF_VAL}"
          fi
        fi
      done
    fi
  done
  return
}
readonly -f __duct_conf

# hosttype

# Mapping of hosttype source=destination (defaults).
declare -a -r _DUCT_HOSTTYPE_MAP=()

# Exported hosttype mapping results (set at runtime).
declare -g -x DUCT_HOSTTYPE=""

# shellcheck disable=SC2206
# Mapping of hosttype source=destination.
declare -g -a DUCT_HOSTTYPE_MAP=( ${DUCT_HOSTTYPE_MAP[@]:-${_DUCT_HOSTTYPE_MAP[@]}} )

# Exported hosttype common variants.
declare -g -x -a DUCT_HOSTTYPE_COMMON=()

# deps: duct-msg
# intl: false
# life: core
# desc: Process hosttype mapping and set matching hosttype to `DUCT_HOSTTYPE`.
# opts:
__duct_hosttype() {
  local HOSTTYPE_DST
  local HOSTTYPE_MAP
  local HOSTTYPE_SHELL="$HOSTTYPE"
  local HOSTTYPE_SRC

  case "$HOSTTYPE_SHELL"
  in
    aarch64)  DUCT_HOSTTYPE_COMMON+=( "arm64" ) ;;
    amd64)    DUCT_HOSTTYPE_COMMON+=( "x86_64" ) ;;
    arm64)    DUCT_HOSTTYPE_COMMON+=( "aarch64" ) ;;
    x86_64)   DUCT_HOSTTYPE_COMMON+=( "amd64" ) ;;

    arm*)     DUCT_HOSTTYPE_COMMON+=( "arm" ) ;;
  esac

  DUCT_HOSTTYPE_COMMON+=( "$HOSTTYPE_SHELL" )

  if [[ "${#DUCT_HOSTTYPE_MAP[@]}" -eq 0 ]]
  then
    DUCT_HOSTTYPE="$HOSTTYPE_SHELL"
    __duct_msg d "$DUCT_HOSTTYPE (DUCT_HOSTTYPE)"
    return
  fi

  __duct_msg d "$HOSTTYPE_SHELL mapping '${DUCT_HOSTTYPE_MAP[*]}'"

  for HOSTTYPE_MAP in "${DUCT_HOSTTYPE_MAP[@]}"
  do
    HOSTTYPE_SRC="${HOSTTYPE_MAP%%=*}"
    HOSTTYPE_DST="${HOSTTYPE_MAP##*=}"

    if [[ "$HOSTTYPE_SHELL" == "$HOSTTYPE_SRC" ]]
    then
      HOSTTYPE_SHELL="$HOSTTYPE_DST"
    fi
  done

  DUCT_HOSTTYPE="$HOSTTYPE_SHELL"
  __duct_msg d "$DUCT_HOSTTYPE (DUCT_HOSTTYPE)"
}
readonly -f __duct_hosttype

# ostype

# Mapping of ostype source=destination (defaults).
declare -a -r _DUCT_OSTYPE_MAP=()

# Exported ostype mapping results (set at runtime).
declare -g -x DUCT_OSTYPE="${DUCT_OSTYPE:-}"

# Exported ostype extra information (set at runtime).
declare -g -x DUCT_OSTYPE_EXTRA="${DUCT_OSTYPE_EXTRA:-}"

# shellcheck disable=SC2206
# Mapping of ostype source=destination.
declare -g -a DUCT_OSTYPE_MAP=( ${DUCT_OSTYPE_MAP[@]:-${_DUCT_OSTYPE_MAP[@]}} )

# deps: duct-msg
# intl: false
# life: core
# desc: Process ostype mapping and set matching ostype to `DUCT_OSTYPE`.
# opts:
__duct_ostype() {
  local OSTYPE_DST
  local OSTYPE_MAP
  local OSTYPE_SHELL="$OSTYPE"
  local OSTYPE_SRC

  # name-extra
  if [[ "$OSTYPE_SHELL" =~ ([a-z]+)-?([a-z]+)?$ ]]
  then
    DUCT_OSTYPE_EXTRA="${BASH_REMATCH[-1]}"
    OSTYPE_SHELL="${BASH_REMATCH[-2]}"

  # nameversion
  elif [[ "$OSTYPE_SHELL" =~ ([a-z]+)([0-9.]+)?$ ]]
  then
    DUCT_OSTYPE_EXTRA="${BASH_REMATCH[-1]}"
    OSTYPE_SHELL="${BASH_REMATCH[-2]}"
  fi

  if [[ "${#DUCT_OSTYPE_MAP[@]}" -eq 0 ]]
  then
    DUCT_OSTYPE="$OSTYPE_SHELL"
    __duct_msg d "$DUCT_OSTYPE (DUCT_OSTYPE)"
    return
  fi

  __duct_msg d "$OSTYPE_SHELL mapping '${DUCT_OSTYPE_MAP[*]}'"

  for OSTYPE_MAP in "${DUCT_OSTYPE_MAP[@]}"
  do
    OSTYPE_SRC="${OSTYPE_MAP%%=*}"
    OSTYPE_DST="${OSTYPE_MAP##*=}"

    if [[ "$OSTYPE_SHELL" == "$OSTYPE_SRC" ]]
    then
      OSTYPE_SHELL="$OSTYPE_DST"
    fi
  done

  DUCT_OSTYPE="$OSTYPE_SHELL"
  __duct_msg d "$DUCT_OSTYPE (DUCT_OSTYPE)"
}
readonly -f __duct_ostype

# umask

# Use umask
declare -g DUCT_UMASK="${DUCT_UMASK:-022}"

# Directory mode from umask (set at run-time).
declare -g -x DUCT_UMASK_DMODE=""

# File mode from umask (set at run-time).
declare -g -x DUCT_UMASK_FMODE=""

# deps: duct-msg
# intl: true
# life: core
# desc: Set a umask to work with.
# opts:
__duct_umask() {
  __duct_intl

  __duct_msg d "$DUCT_UMASK (DUCT_UMASK)"
  umask "$DUCT_UMASK"

  DUCT_UMASK_DMODE="$( printf '%#o' $(( 0777 & ~DUCT_UMASK )) )"
  __duct_msg d "$DUCT_UMASK_DMODE (DUCT_UMASK_DMODE)"

  DUCT_UMASK_FMODE="$( printf '%#o' $(( 0777 & ~0111 & ~DUCT_UMASK )) )"
  __duct_msg d "$DUCT_UMASK_FMODE (DUCT_UMASK_FMODE)"
}
readonly -f __duct_umask

# duct init

# Quiet init messages.
declare -g DUCT_INIT_QUIET="${DUCT_INIT_QUIET:-false}"

# deps: duct-msg
# intl: true
# life: core
# desc: Run initial duct requirements.
# opts:
__duct_init() {
  local INIT_MSG_LEVEL

  __duct_intl

  if [[ "$DUCT_INIT_QUIET" == true ]]
  then
    # store msg level
    INIT_MSG_LEVEL="$DUCT_MSG_MAX_LEVEL"
    DUCT_MSG_MAX_LEVEL=0
  fi

  # bash
  __duct_bash

  # env
  __duct_env

  # conf
  __duct_conf

  # os type
  __duct_ostype

  # host type
  __duct_hosttype

  # umask
  __duct_umask

  if [[ "$DUCT_INIT_QUIET" == true ]]
  then
    # restore msg level
    DUCT_MSG_MAX_LEVEL="$INIT_MSG_LEVEL"
  fi
}
readonly -f __duct_init

# duct

# Enable/disable duct caller debug.
declare -g DUCT_DEBUG="${DUCT_DEBUG:-false}"

# deps: duct-msg
# intl: true
# life: core
# desc: Main duct plugin and command processor.
# opts: <plugin> <command> [extra-options]
duct() {
  local -a DUCT_OPTS=( "$@" )

  local -a DUCT_KEEP=()
  local DUCT_BASE
  local DUCT_CALL
  local DUCT_FUNC=""
  local DUCT_ITEM

  if [[ -z "${DUCT_OPTS[*]}" ]] || [[ "${DUCT_OPTS[*]}" =~ ^(logo|version)$ ]]
  then
    __duct_logo
    return
  fi

  DUCT_BASE="${DUCT_OPTS[0]}"
  unset "DUCT_OPTS[0]"

  # rewrite index
  DUCT_OPTS=( "${DUCT_OPTS[@]}" )
  DUCT_CALL="__duct_${DUCT_BASE}"

  if [[ "$DUCT_DEBUG" == true ]]
  then
    __duct_msg d "base: $DUCT_BASE"
    __duct_msg d "opts: ${DUCT_OPTS[*]}"
  fi

  # handle plugin direct function calls
  if [[ "$( type -t "${DUCT_CALL}" )" == "function" ]]
  then
    DUCT_FUNC="$DUCT_CALL"

    if [[ "$DUCT_DEBUG" == true ]]
    then
      __duct_msg d "func: $DUCT_FUNC"
    fi
  fi

  # handle plugin sub function calls
  for (( DUCT_ITEM=${#DUCT_OPTS[@]}-1; DUCT_ITEM>=0; DUCT_ITEM--))
  do
    DUCT_TEST="${DUCT_CALL}_${DUCT_OPTS[*]:0:(( DUCT_ITEM + 1 ))}"
    DUCT_TEST="${DUCT_TEST// /_}"

    if [[ "$( type -t "${DUCT_TEST}" )"  == "function"  ]]
    then
      DUCT_FUNC="$DUCT_TEST"

      if [[ "$DUCT_DEBUG" == true  ]]
      then
        __duct_msg d "func: $DUCT_TEST"
      fi
      break
    else
      DUCT_KEEP+=( "${DUCT_OPTS[DUCT_ITEM]}" )

      if [[ "$DUCT_DEBUG" == true ]]
      then
        __duct_msg d "keep: ${DUCT_KEEP[*]}"
      fi
    fi
  done

  # rewrite opts
  DUCT_OPTS=()
  for (( DUCT_ITEM=${#DUCT_KEEP[@]}-1; DUCT_ITEM>=0; DUCT_ITEM-- ))
  do
    DUCT_OPTS+=( "${DUCT_KEEP[DUCT_ITEM]}" )
  done
  unset DUCT_KEEP

  if [[ "$DUCT_DEBUG" == true ]]
  then
    __duct_msg d "opts: ${DUCT_OPTS[*]}"
  fi

  if [[ -z "$DUCT_FUNC" ]]
  then
    __duct_msg e "'duct $DUCT_BASE ${DUCT_OPTS[*]:-\b}' not found!"
    return 1
  else
    if [[ "$DUCT_DEBUG" == true ]]
    then
      __duct_msg d "call: $DUCT_FUNC ${DUCT_OPTS[*]}"
    fi
    "$DUCT_FUNC" "${DUCT_OPTS[@]}"
  fi
}
readonly -f duct

# bin check

# List of binaries to check (defaults).
declare -a _DUCT_BIN_CHECK_LIST=()

# shellcheck disable=SC2206
# List of binaries to check.
declare -g -a DUCT_BIN_CHECK_LIST=( ${DUCT_BIN_CHECK_LIST[@]:-${_DUCT_BIN_CHECK_LIST[@]}} )

# deps: duct-msg
# intl: false
# life: core
# desc: Check a list of binaries/commands for availibility.
# opts: [bin-list[@]]
__duct_bin_check() {
  local -a BIN_LIST=( "${@:-${DUCT_BIN_CHECK_LIST[@]}}" )
  local BIN_CMD
  local BIN_PATH
  local BIN_RC=0
  local BIN_HELP_RC=0

  if [[ ${#BIN_LIST[@]} -eq 0 ]]
  then
    __duct_msg w "empty binary list!"
  fi

  for BIN_CMD in "${BIN_LIST[@]}"
  do
    BIN_PATH=$(type -P "$BIN_CMD" || :)

    if [[ -n "$BIN_PATH" ]]
    then
      command "$BIN_PATH" --help >/dev/null 2>&1 || BIN_HELP_RC=$?

      case "$BIN_HELP_RC" in
        0)
          __duct_msg d "'$BIN_PATH' found"
        ;;
        127)
          __duct_msg w "'$BIN_PATH' found, but command returned 127 (not found)!"
        ;;
        *)
          __duct_msg d "'$BIN_PATH' found ($BIN_HELP_RC)"
        ;;
      esac
    else
      __duct_msg e "'$BIN_CMD' not found!"
      (( BIN_RC+=1 ))
    fi
  done

  if [[ "$BIN_RC" -gt 0 ]]
  then
    return 1
  else
    return 0
  fi
}
readonly -f __duct_bin_check

# var check

# List of variables to check (defaults).
declare -a _DUCT_VAR_CHECK_LIST=()

# shellcheck disable=SC2206
# List of variables to check.
declare -g -a DUCT_VAR_CHECK_LIST=( ${DUCT_VAR_CHECK_LIST[@]:-${_DUCT_VAR_CHECK_LIST[@]}} )

# deps: duct-msg
# intl: false
# life: core
# desc: Check if variables are present and set.
# opts: [var[@]]
__duct_var_check() {
  local -a VAR_LIST=( "${@:-${DUCT_VAR_CHECK_LIST[@]}}" )
  local VAR
  local VAR_RC=0

  set +u
  for VAR in "${VAR_LIST[@]}"
  do
    if [[ -n "${!VAR}" ]]
    then
      if [[ "$VAR" =~ (PASS|SECRET|TOKEN) ]]
      then
        __duct_msg d "$VAR set ([HIDDEN])"
      else
        __duct_msg d "$VAR set (${!VAR})"
      fi
    else
      __duct_msg e "$VAR unset!"
      (( VAR_RC+=1 ))
    fi
  done
  set -u

  if [[ "$VAR_RC" -gt 0 ]]
  then
    return 1
  fi
}
readonly -f __duct_var_check

# ver check

# deps: duct-msg
# intl: false
# life: core
# desc: Check minimal required version.
# opts: <command> <minimal-version> <match>
__duct_ver_check() {
  local VER_CMD="$1"
  local VER_MIN="$2"
  local VER_MATCH="$3"

  local -a VER_MININFO
  local -a VER_VERSINFO
  local VER_RC=0
  local VER_VERSION

  IFS="." read -r -a VER_MININFO <<< "$VER_MIN"

  # shellcheck disable=SC2046
  set -- $( command $VER_CMD --version )
  VER_VERSION="${!VER_MATCH}"

  # remove *-
  VER_VERSION="${VER_VERSION#*-}"

  # unknown version
  if [[ "$VER_VERSION" =~ (\-) ]]
  then
    __duct_msg w "$VER_CMD version unknown ($VER_VERSION)!"
    return

  # accept master|main version
  elif [[ ! "$VER_VERSION" =~ (master|main) ]]
  then
    IFS="." read -r -a VER_VERSINFO <<< "$VER_VERSION"

    if [[ "${VER_VERSINFO[0]}" -lt "${VER_MININFO[0]}" ]]
    then
      (( VER_RC+=1 ))
    elif [[ "${VER_VERSINFO[0]}" -eq "${VER_MININFO[0]}" ]] && [[ "${VER_VERSINFO[1]}" -lt "${VER_MININFO[1]}" ]]
    then
      (( VER_RC+=1 ))
    fi
  fi

  if [[ "$VER_RC" -gt 0 ]]
  then
    __duct_msg e "$VER_CMD version $VER_VERSION is unsupported!"
    __duct_msg e "minimal required version $VER_MIN"
    return 1
  else
    __duct_msg d "$VER_CMD version $VER_VERSION"
  fi
}
readonly -f __duct_ver_check
